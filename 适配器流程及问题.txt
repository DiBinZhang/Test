Uart1
用于接收pc端发送过来的报文，以下是大概运行逻辑
1、需要先在reg_handler()函数中注册指定的命令处理函数，存放在指针函数数组 g_pc_handler[] 中；
2、Uart1中断处理函数在接收到报文数据后，会通过解析代码函数--PARSE_PACKAGE()，通过使用状态机，按通讯规约格式来确保报文的完整接收；
3、当报文接收状态为GotPackage，证明已成功接收到完整的报文，之后根据报文中的command位来选择处理函数g_pc_handler[command]() 或者 g_default_pc_handler();
4、g_pc_handler[command]()中存放的处理函数，针对的目标地址是适配器本身，不需要发送给钥匙
5、g_default_pc_handler()函数，针对的目标地址是钥匙，需要适配器将该报文通过Uart0发送给钥匙；若没有钥匙在位时，还会重置g_query_key_timeout，触发Timer_A查询钥匙在位情况。


Uart0
 用于接收key端的报文 有以下两种情况：
(1) 钥匙充电状态回应报文处理函数，由适配器本身进行处理。
(2) 其他报文命令处理函数，直接发送给PC端。


Timer_A
1、在未同步且g_query_key_timeout>0时，每130毫秒查询一次钥匙是否在位
2、每200ms查询一次钥匙状态
	· KEY_FLAG_TAKEN(不在位状态)：在位--切换充电状态；不在位--关闭充电功能	
	· KEY_FLAG_CHARGING(充电状态)：获取充电状态：若充满60分钟或钥匙返回满电状态，则切换刚满电状态；若未满60分钟，则维持当前状态；若检查不到钥匙在位，则返回不在位状态；
	· KEY_FLAG_ON_FULL(刚满电状态)：获取充电状态：若充满60分钟或钥匙已达到饱和标志，则切换满电状态；若钥匙返回的报文为充电状态，则切换到充电状态；若钥匙不在位，则切换为不在位状态；
	· KEY_FLAG_FULL(满电状态): 获取钥匙状态：若在位，则关闭充电功能；若不在位，则切换为不在位状态；

Timer_B
用于控制LED灯闪烁和Uart0延时发送作用。



问题：
1. 同步的作用？


3. CHECK_IO(6,3)引脚口为高时为什么需要延时一段时间后再发？
CHECK_IO(6,3)引脚为低时，Uart0才能正常通信，并发送报文给钥匙。




5. asm("mov #live_update,PC");  和 void live_update() @ "LIVE_UPDATE_CODE"？
(1)asm("mov #live_update,PC");写法的作用
	① asm()是c语言中的内嵌汇编写法，意思是将live_update的地址传递给PC，实现跳转更新；
	② 因为MSP430为RISV--C架构，mov汇编语法为 "mov  源操作数，目标操作数"; 在ARM架构下，mov汇编语法为 "mov  目标操作数, 源操作数"
(2)void live_update() @ "LIVE_UPDATE_CODE" , @ "LIVE_UPDATE_CODE"语法的作用？
	①@"LIVE_UPDATE_CODE"用于指定函数或变量的存储位置（内存地址或段名）
	②不同的编译器下写法不同
		i. GCC: __attribute__((section("name")))
		ii.Keil MDK: __attribute__((at(address)))
		iii.IAR: 使用@"name" 或者 #pragma LOCATION("name")

更新，通过跳转到LIVE_UPDATE_CODE内存段的 live_update() 函数进行升级，将UPDATE_CODE_START+2开始的数据写入到PROGRAM_CODE_START地址，将INTERUPT_CODE_START处开始的256Byte的中断向量表 写入0xFF00处，然后软件复位系统即可完成升级


4-27
1. CHECK_IO(3,5)的引脚口如何检查钥匙是否在位？
代码上：低电平为在位，高电平为不在位
低电平：TLP112 IA->IE 的电流 If > 0, 输出V为低电平
高电平：TLP112 IA->IE 的电流 If = 0，输出为高电平
未在位 或者 钥匙充满电时，CHECK_IO(3,5)引脚口为高电平；在位时且未满电时，CHECK_IO(3,5)引脚口为低电平 

2. P62引脚用作看门狗功能
因为连接WDI的MCU引脚P62需要定期输出跳变信号，周期为1.6s，若引脚没有在该周期内输出跳变信号，则会触发芯片复位。

3. 什么情况下才会触发P13的外部中断？
安全状态，P13引脚为低电平；出现断路问题，P13引脚为高电平；

安全状态, MOS管为截止，这样OPRO端才为高电平，若为截止此时OTEST(P13)则必须为低电平状态，即UC5光电耦合没有导通。

4.串口报文超时检测。
Uart0 110ms检测一次，当接收完报文头后，若110ms内没有接收到接下来的报文数据，则重新开始接收报文。
Uart1 120ms检测一次，当接收完报文头后，若120ms内没有接收到接下来的报文数据，则重新开始接收报文。
报文处理流程
	0x55 -- 0xAA -- 接收头部接下来的数据直到 接收到第0x0B的数据 -- 判断头部校验和是否通过 -- 根据数据包长度选择是否接收数据并计算校验和 -- 0x96结束符号


更新适配器程序流程 发送更新适配器程序(0x1C) -- 发送适配器程序(0x1B) -- 发送中断向量表(0x19) -- 发送更新适配器程序(0x1C)



总结：
Flash的擦写流程：
适配器地址：0xFD00~0xFD01   ID:0xFD02 ~0xFD11
适配器更新：
#define PROGRAM_CODE_START 0x5000	//充电座主程序起始地址
#define UPDATE_CODE_START 0xB000	       //更新数据存储区地址
#define INTERUPT_CODE_START 0xD800     //中断向量存储区地址

低功耗配置
低功耗模式为LPM0，当TimerA和B中断触发后，就会退出LPM0，周期为10ms。


需要的外设资源
两个Timer -- 周期10ms
两个Uart  -- 波特率57600		
一个外部中断 -- 用于断路检测 -- P13
看门狗 -- P62  
充电使能引脚口  -- P63
蜂鸣器 -- P14


GD32L233
Flash擦写流程：擦写

低功耗有十种





今天目标，对适配器的整体业务逻辑进行梳理，并查漏补缺
1、适配器更新功能
（1）PC端发送的更新命令顺序：发送更新适配器程序(0x1C) -- 发送适配器程序(0x1B) -- 发送中断向量表(0x19) -- 发送更新适配器程序(0x1C)
（2）下载最新代码逻辑：收到PC端发送给适配器的更新命令后，将适配器的最新程序写入UPDATE_CODE_START处，头两位为长度；之后再将发送过来的向量表写入INTERUPT_CODE_START处，之后重新复位，开始第（3）点的更新代码逻辑。
  注意点：①要判断报文的目的地址是否为适配器本身；②接收程序报文时，要根据其中的控制域位判断数据包是否正确。
（3）更新代码逻辑：判断中断向量表存放位置 INTERUPT_CODE_START 是否有有效值（256个字节不全为0xFF）
        ① True：跳转到 "LIVE_UPDATE_CODE" 代码区，执行live_update()，将UPDATE_CODE_START+2处的代码写入PROGRAM_CODE_START处，然后将INTERUPT_CODE_START处的中断向量表更新到 0xFE00；之后进行系统复位就能完成更新功能。
        ② False：执行适配器钥匙检测功能。

2、钥匙状态检测
（1）钥匙状态：KEY_FLAG_TAKEN (0, 不在位)、KEY_FLAG_CHARGING(1, 正在充电)、KEY_FLAG_ON_FULL(2, 刚充满电)、KEY_FLAG_FULL(3, 充满电)
（2）钥匙状态查询时间--时基为10ms
① 当g_query_key_timeout > 0 时（当PC端发送给钥匙报文时 或 钥匙发送给PC报文时，都会赋值g_query_key_timeout  = 30 (s)）
i.若未同步且Uart0未处在接收报文状态时，适配器1s查询一次钥匙在位状态，若连续两次查询检测不到钥匙，则钥匙状态切换为不在位（清空key地址），若在位无操作。
ii.若同步且钥匙和PC之间有数据交流时，则适配器会以30s为周期查询更新钥匙状态。
iii.若同步且钥匙和PC之间没有数据交流时，则适配器以200ms为周期查询更新钥匙状态。
②未同步且g_query_key_timeout <= 0时，有以下两种情况
i.未在位：每隔400ms，使能充电并查询一次钥匙状态，查询到在位后，就切换成充电状态。
ii.在位：适配器以200ms为周期查询更新钥匙充电状态。
（3）钥匙充电状态变化逻辑：
①KEY_FLAG_TAKEN(不在位状态)：检测钥匙状态，若在位--切换充电状态；不在位--关闭充电功能；    
②KEY_FLAG_CHARGING(充电状态)：获取充电状态：若充满60分钟或钥匙返回满电状态，则切换刚满电状态；若未满60分钟，则维持当前状态；若检查不到钥匙在位，则返回不在位状态；
③KEY_FLAG_ON_FULL(刚满电状态)：获取充电状态：若充满60分钟或钥匙已达到饱和标志，则切换满电状态；若钥匙返回的报文为充电状态，则切换到充电状态；若钥匙不在位，则切换为不在位状态；
④KEY_FLAG_FULL(满电状态): 获取钥匙状态：若在位，则关闭充电功能；若不在位，则切换为不在位状态；

3、PC端报文处理  ：设置适配器模式是否需要？
（1） 报文接收处理状态：NoHeader、GotFirstHeader、GotSecondHeader、GotData、RecvData、GotPackage
NotHeader：表示没有接收到报文头的第一个字节标志 0x55；
GotFirstHeader：已经接收到报文头 0x55标志，接下来接收第二个字节标志0xAA；
GotSecondHeader：报文头0x55 0xAA接收完成，接下来开始接收头部其他数据共 0x08
RecvData：报文头部数据接收完成，根据头部中断数据长度标志位来接收指定长度的数据
GotData：报文数据部分接收完毕，开始接收结束标志 0x96
GotPackage：报文接收完成，可以开始执行相关命令函数
（2）报文校验：采用校验和方式，共有两部分进行校验，头部数据 0x03 ~ 0x0A 的数据进行一次校验，校验和一个字节；数据校验 0x0C ~ 结束符号前两位进行一次校验， 校验和两个字节.
（3）报文处理超时操作，当接收到第一个报文头字节0x55后，开始报文超时处理，若1s内没有接收到报文头的第二个字节，则重新开始接收报文。
（4）报文命令处理：接收报文后，根据报文头部数据的命令位来选择执行对应的命令处理函数，适配器接收的来自PC的报文主要分为两类：一、报文目标是适配器；二、报文目标是钥匙;
 ①当报文目标是适配器时，则无需钥匙在位，适配器自身进行处理（）
 ②当报文目标是钥匙时，适配器需要先判断是否有钥匙在位且钥匙地址是否同报文的目的地址相同，若相同适配器只需要充当传递方，将PC发送的报文转发给钥匙端。适配器发送给钥匙前，需要先确保充电使能引脚为低，才能成功发送给钥匙。若不为低电平，则需置低，在延时50个时间周期后再发送报文。


4、Key端报文处理
报文接收处理同PC端是同个操作。
接收Key发送过来的报文后，先接收其中的Key端的钥匙地址，之后再根据其中的Command位来执行命令处理函数
Key端的命令处理函数主要分为两类
①向适配器发送的充电状态的回应：命令码：0xFC，钥匙回应当前剩余的电压值，满电时>405
②给PC端发送的回应：直接将报文转发给PC端。若为任务命令的回应，则灯光闪烁。

5、断路检测
使用外部中断线，当对应的外部中断线发生从低到高的跳变时，触发该中断；此时会触发蜂鸣器产生警告。

6、低功耗模式
初始化 -- 喂狗 -- （低功耗模式 -- 定时器中断激活 -- 退出低功耗模式 -- 喂狗 ）循环往复-- 低功耗模式


正在充电 --> 充满电判断
1、200ms * 2 * 11 = 4400ms
2、钥匙返回充满电报文

充满电：
关闭充电时间 7 * 200 = 1400ms，再检测P35则为低电平


串口初始化 -- 中断函数 -- 调用外部函数
