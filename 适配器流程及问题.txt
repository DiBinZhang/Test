Uart1
用于接收pc端发送过来的报文，以下是大概运行逻辑
1、需要先在reg_handler()函数中注册指定的命令处理函数，存放在指针函数数组 g_pc_handler[] 中；
2、Uart1中断处理函数在接收到报文数据后，会通过解析代码函数--PARSE_PACKAGE()，通过使用状态机，按通讯规约格式来确保报文的完整接收；
3、当报文接收状态为GotPackage，证明已成功接收到完整的报文，之后根据报文中的command位来选择处理函数g_pc_handler[command]() 或者 g_default_pc_handler();
4、g_pc_handler[command]()中存放的处理函数，针对的目标地址是适配器本身，不需要发送给钥匙
5、g_default_pc_handler()函数，针对的目标地址是钥匙，需要适配器将该报文通过Uart0发送给钥匙；若没有钥匙在位时，还会重置g_query_key_timeout，触发Timer_A查询钥匙在位情况。


Uart0
 用于接收key端的报文 有以下两种情况：
(1) 钥匙充电状态回应报文处理函数，由适配器本身进行处理。
(2) 其他报文命令处理函数，直接发送给PC端。


Timer_A
1、在未同步且g_query_key_timeout>0时，每130毫秒查询一次钥匙是否在位
2、每200ms查询一次钥匙状态
	· KEY_FLAG_TAKEN(不在位状态)：在位--切换充电状态；不在位--关闭充电功能	
	· KEY_FLAG_CHARGING(充电状态)：获取充电状态：若充满60分钟或钥匙返回满电状态，则切换刚满电状态；若未满60分钟，则维持当前状态；若检查不到钥匙在位，则返回不在位状态；
	· KEY_FLAG_ON_FULL(刚满电状态)：获取充电状态：若充满60分钟或钥匙已达到饱和标志，则切换满电状态；若钥匙返回的报文为充电状态，则切换到充电状态；若钥匙不在位，则切换为不在位状态；
	· KEY_FLAG_FULL(满电状态): 获取钥匙状态：若在位，则关闭充电功能；若不在位，则切换为不在位状态；

Timer_B
用于控制LED灯闪烁和Uart0延时发送作用。



问题：
1. 同步的作用？


3. CHECK_IO(6,3)引脚口为高时为什么需要延时一段时间后再发？
CHECK_IO(6,3)引脚为低时，Uart0才能正常通信，并发送报文给钥匙。




5. asm("mov #live_update,PC");  和 void live_update() @ "LIVE_UPDATE_CODE"？
(1)asm("mov #live_update,PC");写法的作用
	① asm()是c语言中的内嵌汇编写法，意思是将live_update的地址传递给PC，实现跳转更新；
	② 因为MSP430为RISV--C架构，mov汇编语法为 "mov  源操作数，目标操作数"; 在ARM架构下，mov汇编语法为 "mov  目标操作数, 源操作数"
(2)void live_update() @ "LIVE_UPDATE_CODE" , @ "LIVE_UPDATE_CODE"语法的作用？
	①@"LIVE_UPDATE_CODE"用于指定函数或变量的存储位置（内存地址或段名）
	②不同的编译器下写法不同
		i. GCC: __attribute__((section("name")))
		ii.Keil MDK: __attribute__((at(address)))
		iii.IAR: 使用@"name" 或者 #pragma LOCATION("name")

更新，通过跳转到LIVE_UPDATE_CODE内存段的 live_update() 函数进行升级，将UPDATE_CODE_START+2开始的数据写入到PROGRAM_CODE_START地址，将INTERUPT_CODE_START处开始的256Byte的中断向量表 写入0xFF00处，然后软件复位系统即可完成升级


4-27
1. CHECK_IO(3,5)的引脚口如何检查钥匙是否在位？
代码上：低电平为在位，高电平为不在位
低电平：TLP112 IA->IE 的电流 If > 0, 输出V为低电平
高电平：TLP112 IA->IE 的电流 If = 0，输出为高电平
未在位 或者 钥匙充满电时，CHECK_IO(3,5)引脚口为高电平；在位时且未满电时，CHECK_IO(3,5)引脚口为低电平 

2. P62引脚用作看门狗功能
因为连接WDI的MCU引脚P62需要定期输出跳变信号，周期为1.6s，若引脚没有在该周期内输出跳变信号，则会触发芯片复位。

3. 什么情况下才会触发P13的外部中断？
安全状态，P13引脚为低电平；出现断路问题，P13引脚为高电平；

安全状态, MOS管为截止，这样OPRO端才为高电平，若为截止此时OTEST(P13)则必须为低电平状态，即UC5光电耦合没有导通。

4.串口报文超时检测。
Uart0 110ms检测一次，当接收完报文头后，若110ms内没有接收到接下来的报文数据，则重新开始接收报文。
Uart1 120ms检测一次，当接收完报文头后，若120ms内没有接收到接下来的报文数据，则重新开始接收报文。
报文处理流程
	0x55 -- 0xAA -- 接收头部接下来的数据直到 接收到第0x0B的数据 -- 判断头部校验和是否通过 -- 根据数据包长度选择是否接收数据并计算校验和 -- 0x96结束符号


更新适配器程序流程 发送更新适配器程序(0x1C) -- 发送适配器程序(0x1B) -- 发送中断向量表(0x19) -- 发送更新适配器程序(0x1C)



总结：
Flash的擦写流程：
适配器地址：0xFD00~0xFD01   ID:0xFD02 ~0xFD11
适配器更新：
#define PROGRAM_CODE_START 0x5000	//充电座主程序起始地址
#define UPDATE_CODE_START 0xB000	       //更新数据存储区地址
#define INTERUPT_CODE_START 0xD800     //中断向量存储区地址

低功耗配置
低功耗模式为LPM0，当TimerA和B中断触发后，就会退出LPM0，周期为10ms。


需要的外设资源
两个Timer -- 周期10ms
两个Uart  -- 波特率57600		
一个外部中断 -- 用于断路检测 -- P13
看门狗 -- P62  
充电使能引脚口  -- P63
蜂鸣器 -- P14


GD32L233
Flash擦写流程：擦写

低功耗有十种

